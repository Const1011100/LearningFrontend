// ================================================================================================
//*-Week №2 flattenAndSort (Monday)
/*
Напишіть функцію flattenAndSort, яка приймає будь-яку кількість вкладених масивів чисел,
розгладжує їх до одного рівня, прибирає дублікати та повертає відсортований масив.
Вхідні дані гарантовано складаються лише з цілих чисел.
flattenAndSort([[3, 2, 1], [4, 6, 5], [9, 7, 8]]) // → [1, 2, 3, 4, 5, 6, 7, 8, 9]
flattenAndSort([[], [1], [1, 1, 2]]) // → [1, 2]
*/
// Мій варіант
function flattenAndSort(array) {
  const unique = new Set(
    array
      .toString()
      .split(',')
      .filter((e) => e !== '')
      .map((e) => Number(e))
      .sort((a, b) => a - b)
  );
  return Array.from(unique);
}

// Ідеальний варіант від ChatGPT
// !!!:
/*
Рекомендація: використовуй flat() для більш читабельного та надійного коду.
*/
function flattenAndSort_(array) {
  const flat = array.flat(Infinity); // Розгладжує будь-який рівень вкладеності
  const unique = [...new Set(flat)];
  return unique.sort((a, b) => a - b);
}
// ================================================================================================
// ================================================================================================
//*-Week №2 camelToSnake (ChatGPT) (Tuesday)
/*
Створіть функцію camelToSnake, що переводить camelCase-рядок у snake_case.
Тільки латинські літери та цифри. Перший символ — літера.
camelToSnake('thisIs7Kyu')     // → 'this_is_7_kyu'
camelToSnake('already_snake')  // → 'already_snake'
*/
// Мій варіант з допомогою ChatGPT
function camelToSnake(str) {
  return str.replace(
    /([A-Z]|\d+)/g,
    (match, _1, offset) => (offset ? '_' : '') + match.toLowerCase()
  );
}
// Ідеальний варіант від DeepSeek
function camelToSnake_(str) {
  return str
    .replace(/([A-Z0-9])/g, '_$1') // Додає підкреслення перед великими літерами та цифрами
    .toLowerCase() // Перетворює все у нижній регістр
    .replace(/^_/, '') // Видаляє підкреслення на початку (якщо є)
    .replace(/_+/g, '_'); // Замінює множинні підкреслення на одне
}
// ================================================================================================
// ================================================================================================
//*-Week №2 Counter class (ChatGPT) (Wednesday)
/*
Реалізуйте клас Counter з приватним полем #value. Поведінка:
Метод / властивість	Опис
constructor(start = 0)	створює лічильник із початковим значенням
inc(step = 1)	збільшує #value на step, повертає нове значення
dec(step = 1)	зменшує #value на step, повертає нове значення
get value()	гетер, повертає поточне значення
static merge(...counters)	повертає новий Counter, значення якого — сума всіх #value переданих лічильників
Використайте сучасний синтаксис JS (private fields, getters, static).

Приклад
const a = new Counter(2);
a.inc();              // 3
a.dec(2);             // 1
const b = new Counter(4);
const c = Counter.merge(a, b);
c.value;              // 5
*/
// Мій варіант

// Ідеальний варіант від ChatGPT
// ================================================================================================
// ================================================================================================
//*-Week №2 promisify (ChatGPT) (Thursday)
/*
Напишіть функцію promisify, яка приймає Node-style функцію fn(...args, callback) і
повертає нову функцію, що працює з Promise.

Callback має сигнатуру callback(error, data).

Приклад
function asyncAdd(a, b, cb) {
  setTimeout(() => cb(null, a + b), 10);
}
const promisedAdd = promisify(asyncAdd);
promisedAdd(2, 3).then(console.log); // 5
*/
// Мій варіант

// Ідеальний варіант від ChatGPT
// ================================================================================================
// ================================================================================================
//*-Week №2 retry (ChatGPT) (Friday)
/*
Створіть асинхронну функцію retry, яка виконує іншу асинхронну функцію fn
до attempts раз (максимум) з затримкою delay мс між повторними спробами.
Повертає першу успішну відповідь або кидає останню помилку після всіх спроб.
await retry(fetchData, 3, 50);
*/
// Мій варіант

// Ідеальний варіант від ChatGPT

// ================================================================================================
// ================================================================================================
//*-Week №2 delegate (ChatGPT) (Saturday)
/*
Реалізуйте функцію delegate, що спрощує делегування подій.
@param {Element} parent  - батьківський елемент, на який вішаємо слухача
@param {string}  type    - тип події, напр. 'click'
@param {string}  selector- CSS-селектор для цільового елемента
@param {Function} handler- колбек, який викликається з `event` та `target`
@returns {Function}      - функція, що знімає слухача

Алгоритм такий: коли подія стається на parent або його нащадках,
перевірити, чи event.target відповідає selector (або має предка, що відповідає),
і викликати handler(event, matchedTarget).

Функція має працювати в браузері та під jsdom (який використовується в Codewars).
*/
// Мій варіант

// Ідеальний варіант від ChatGPT
// ================================================================================================
// ================================================================================================
